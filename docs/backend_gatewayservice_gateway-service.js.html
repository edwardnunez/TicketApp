<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: backend/gatewayservice/gateway-service.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: backend/gatewayservice/gateway-service.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import express from 'express';
import axios from 'axios';
import cors from 'cors';
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, resolve } from 'path';
import { existsSync } from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Intentar cargar .env solo si existe (desarrollo local)
// En Docker, las variables vienen del contenedor
const envPath = resolve(__dirname, '../../.env');
if (existsSync(envPath)) {
  dotenv.config({ path: envPath });
}

const app = express();
const port = 8000;

const userServiceUrl = process.env.USER_SERVICE_URL || "http://localhost:8001";
const ticketServiceUrl = process.env.TICKET_SERVICE_URL || "http://localhost:8002";
const eventServiceUrl = process.env.EVENT_SERVICE_URL || "http://localhost:8003";
const locationServiceUrl = process.env.LOCATION_SERVICE_URL || "http://localhost:8004";

const secretKey = process.env.JWT_SECRET;

if (!secretKey) {
  console.error('ERROR: JWT_SECRET no está definido en las variables de entorno');
  console.error('Make sure JWT_SECRET is set in .env (local) or docker-compose.yml (Docker)');
  process.exit(1);
}

app.use(cors());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

const largePayloadMiddleware = express.json({ limit: '50mb' });

app.set("json spaces", 40);

/**
 * Middleware to verify admin authentication
 * Checks for roleToken in Authorization header and verifies admin role
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 * @param {Function} next - Express next middleware function
 */
const verifyAdmin = (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader) {
      return res.status(401).json({
        error: 'No se proporcionó token de autenticación',
        message: 'Se requiere autenticación para acceder a este recurso'
      });
    }

    const token = authHeader.startsWith('Bearer ')
      ? authHeader.slice(7)
      : authHeader;

    if (!token) {
      return res.status(401).json({
        error: 'Token inválido',
        message: 'El token de autenticación no tiene el formato correcto'
      });
    }

    const decoded = jwt.verify(token, secretKey);

    if (!decoded.role || decoded.role !== 'admin') {
      return res.status(403).json({
        error: 'Acceso denegado',
        message: 'No tienes permisos de administrador para acceder a este recurso'
      });
    }

    req.user = decoded;
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        error: 'Token expirado',
        message: 'Tu sesión ha expirado, por favor inicia sesión nuevamente'
      });
    }
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({
        error: 'Token inválido',
        message: 'El token de autenticación no es válido'
      });
    }
    return res.status(500).json({
      error: 'Error de autenticación',
      message: 'Ocurrió un error al verificar tu autenticación'
    });
  }
};

/**
 * Middleware to verify user is authenticated (has valid token)
 * @param {Object} req - Express request object
 * @param {Object} res - Express response object
 * @param {Function} next - Express next middleware function
 */
const verifyAuthenticated = (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader) {
      return res.status(401).json({
        error: 'No autenticado',
        message: 'Debes iniciar sesión para acceder a este recurso'
      });
    }

    const token = authHeader.startsWith('Bearer ')
      ? authHeader.slice(7)
      : authHeader;

    if (!token) {
      return res.status(401).json({
        error: 'Token inválido',
        message: 'El token de autenticación no tiene el formato correcto'
      });
    }

    const decoded = jwt.verify(token, secretKey);
    req.user = decoded;
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({
        error: 'Sesión expirada',
        message: 'Tu sesión ha expirado, por favor inicia sesión nuevamente'
      });
    }
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({
        error: 'Token inválido',
        message: 'El token de autenticación no es válido'
      });
    }
    return res.status(500).json({
      error: 'Error de autenticación',
      message: 'Ocurrió un error al verificar tu autenticación'
    });
  }
};

/**
 * Middleware to verify user can only access their own resources
 * Must be used after verifyAuthenticated
 * @param {string} paramName - Name of the parameter containing userId (default: 'userId')
 */
const verifyOwnership = (paramName = 'userId') => {
  return (req, res, next) => {
    const resourceUserId = req.params[paramName];
    const tokenUserId = req.user.userId;

    if (!tokenUserId) {
      return res.status(401).json({
        error: 'Token inválido',
        message: 'El token no contiene información de usuario'
      });
    }

    if (resourceUserId !== tokenUserId) {
      return res.status(403).json({
        error: 'Acceso denegado',
        message: 'No tienes permiso para acceder a este recurso'
      });
    }

    next();
  };
};

/**
 * Health check endpoint
 * @route GET /health
 * @returns {Object} Service status
 */
app.get("/health", (req, res) => {
  res.json({ status: "OK" });
});

/**
 * Generic error handler for microservice communication
 * @param {Object} res - Express response object
 * @param {Error} error - Error object
 */
const returnError = (res, error) => {
  console.error(error);
  if (error.response) {
    res.status(error.response.status).json({ error: error.response.data.error });
  } else {
    res.status(500).json({ error: "Internal Gateway Error" });
  }
};

// **User Routes**

/**
 * User login endpoint
 * @route POST /login
 * @param {Object} req.body - Login credentials
 * @param {string} req.body.username - Username
 * @param {string} req.body.password - Password
 * @returns {Object} Authentication response with token and user data
 */
app.post("/login", async (req, res) => {
  try {
    const authResponse = await axios.post(`${userServiceUrl}/login`, req.body);
    res.json(authResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * User registration endpoint
 * @route POST /adduser
 * @param {Object} req.body - User registration data
 * @param {string} req.body.name - User's first name
 * @param {string} req.body.surname - User's last name
 * @param {string} req.body.username - Username
 * @param {string} req.body.email - Email address
 * @param {string} req.body.password - Password
 * @returns {Object} Registration response with success status
 */
app.post("/adduser", async (req, res) => {
  try {
    const userResponse = await axios.post(`${userServiceUrl}/adduser`, req.body);
    res.json(userResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Get all users endpoint (Admin only)
 * @route GET /users
 * @returns {Array} List of all users
 */
app.get("/users", verifyAdmin, async (req, res) => {
  try {
    const usersResponse = await axios.get(`${userServiceUrl}/users`);
    res.json(usersResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Search users endpoint
 * @route GET /users/search
 * @param {string} [req.query.username] - Username to search for
 * @param {string} [req.query.userId] - User ID to search for
 * @returns {Object} User data if found
 */
app.get("/users/search", async (req, res) => {
  try {
    const { username, userId } = req.query;

    const queryParams = username ? `?username=${username}` : userId ? `?userId=${userId}` : '';

    const usersResponse = await axios.get(`${userServiceUrl}/users/search${queryParams}`);

    res.json(usersResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Update user endpoint (Protected - User can only edit their own profile)
 * @route PUT /edit-user/:userId
 * @param {string} req.params.userId - User ID to update
 * @param {Object} req.body - Updated user data
 * @returns {Object} Updated user data
 */
app.put("/edit-user/:userId", verifyAuthenticated, verifyOwnership(), async (req, res) => {
  try {
    const { userId } = req.params;
    const updatedUserData = req.body;
    const response = await axios.put(`${userServiceUrl}/edit-user/${userId}`, updatedUserData);

    res.status(200).json(response.data);
  } catch (error) {
    console.error("Error updating user data:", error);
    if (error.response) {
      res.status(error.response.status).json({ error: error.response.data.error });
    } else {
      res.status(500).json({ error: "Internal Server Error" });
    }
  }
});

/**
 * Verify token endpoint
 * @route POST /verifyToken
 * @param {Object} req.body - Token verification data
 * @param {string} req.body.token - JWT token to verify
 * @returns {Object} Token verification response
 */
app.post("/verifyToken", async (req, res) => {
  try {
    const userResponse = await axios.post(`${userServiceUrl}/verifyToken`, req.body);
    res.json(userResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

// **Ticket Routes**

/**
 * Get occupied seats for an event
 * @route GET /tickets/occupied/:eventId
 * @param {string} req.params.eventId - Event ID
 * @returns {Array} List of occupied seat IDs
 */
app.get('/tickets/occupied/:eventId', async (req, res) => {
    try {
      const { eventId } = req.params;
      const ticketResponse = await axios.get(`${ticketServiceUrl}/tickets/occupied/${eventId}`);
      res.json(ticketResponse.data);
    } catch (error) {
      returnError(res, error);
    }
});

/**
 * Purchase tickets endpoint (Protected - Requires authentication)
 * @route POST /tickets/purchase
 * @param {Object} req.body - Ticket purchase data
 * @param {string} req.body.eventId - Event ID
 * @param {Array} req.body.seats - Selected seats
 * @param {Object} req.body.buyerInfo - Buyer information
 * @param {string} req.body.paymentMethod - Payment method
 * @returns {Object} Purchase confirmation with ticket details
 */
app.post('/tickets/purchase', verifyAuthenticated, async (req, res) => {
  try {
    const ticketResponse = await axios.post(`${ticketServiceUrl}/tickets/purchase`, req.body);
    res.json(ticketResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Get detailed tickets for a user (Protected - User can only see their own tickets)
 * @route GET /tickets/user/:userId/details
 * @param {string} req.params.userId - User ID
 * @param {Object} [req.query] - Query parameters for filtering
 * @returns {Array} Detailed ticket information for the user
 */
app.get('/tickets/user/:userId/details', verifyAuthenticated, verifyOwnership(), async (req, res) => {
    try {
      const { userId } = req.params;
      const ticketResponse = await axios.get(`${ticketServiceUrl}/tickets/user/${userId}/details`, {
        params: req.query
      });
      res.json(ticketResponse.data);
    } catch (error) {
      returnError(res, error);
    }
});

/**
 * Get tickets for a user (Protected - User can only see their own tickets)
 * @route GET /tickets/user/:userId
 * @param {string} req.params.userId - User ID
 * @param {Object} [req.query] - Query parameters for filtering
 * @returns {Array} List of tickets for the user
 */
app.get('/tickets/user/:userId', verifyAuthenticated, verifyOwnership(), async (req, res) => {
    try {
      const { userId } = req.params;
      const ticketResponse = await axios.get(`${ticketServiceUrl}/tickets/user/${userId}`, {
        params: req.query
      });
      res.json(ticketResponse.data);
    } catch (error) {
      returnError(res, error);
    }
});

/**
 * Get tickets for an event
 * @route GET /tickets/event/:eventId
 * @param {string} req.params.eventId - Event ID
 * @param {Object} [req.query] - Query parameters for filtering
 * @returns {Object} Ticket statistics and data for the event
 */
app.get('/tickets/event/:eventId', async (req, res) => {
  try {
      const { eventId } = req.params;
      const ticketResponse = await axios.get(`${ticketServiceUrl}/tickets/event/${eventId}`, {
        params: req.query
      });
      res.json(ticketResponse.data);
  } catch (error) {
      returnError(res, error);
  }
});

/**
 * Get specific ticket by ID
 * @route GET /tickets/:id
 * @param {string} req.params.id - Ticket ID
 * @returns {Object} Ticket details
 */
app.get('/tickets/:id', async (req, res) => {
  try {
      const { id } = req.params;
      const ticketResponse = await axios.get(`${ticketServiceUrl}/tickets/${id}`);
      res.json(ticketResponse.data);
    } catch (error) {
      returnError(res, error);
    }
});

/**
 * Get QR code for a ticket
 * @route GET /tickets/:id/qr
 * @param {string} req.params.id - Ticket ID
 * @returns {Object} QR code data for the ticket
 */
app.get('/tickets/:id/qr', async (req, res) => {
  try {
      const { id } = req.params;
      const ticketResponse = await axios.get(`${ticketServiceUrl}/tickets/${id}/qr`);
      res.json(ticketResponse.data);
    } catch (error) {
      returnError(res, error);
    }
});

/**
 * Get events for a user's tickets (Protected - User can only see their own events)
 * @route GET /tickets/user/:userId/events
 * @param {string} req.params.userId - User ID
 * @returns {Array} Events associated with user's tickets
 */
app.get('/tickets/user/:userId/events', verifyAuthenticated, verifyOwnership(), async (req, res) => {
  try {
      const { userId } = req.params;
      const ticketResponse = await axios.get(`${ticketServiceUrl}/tickets/user/${userId}/events`);
      res.json(ticketResponse.data);
    } catch (error) {
      returnError(res, error);
    }
});

/**
 * Get administrator ticket statistics (Admin only)
 * @route GET /tickets/admin/statistics
 * @param {Object} [req.query] - Query parameters for filtering statistics
 * @returns {Object} Administrative ticket statistics
 */
app.get('/tickets/admin/statistics', verifyAdmin, async (req, res) => {
  try {
    const ticketResponse = await axios.get(`${ticketServiceUrl}/tickets/admin/statistics`, {
      params: req.query
    });
    res.json(ticketResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Delete all tickets for an event (Admin only)
 * @route DELETE /tickets/event/:eventId
 * @param {string} req.params.eventId - Event ID
 * @returns {Object} Deletion confirmation
 */
app.delete("/tickets/event/:eventId", verifyAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;
    const ticketResponse = await axios.delete(`${ticketServiceUrl}/tickets/event/${eventId}`);
    res.json(ticketResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Cancel/delete a specific ticket
 * @route DELETE /tickets/:id
 * @param {string} req.params.id - Ticket ID to cancel/delete
 * @returns {Object} Cancellation confirmation
 */
app.delete('/tickets/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const ticketResponse = await axios.delete(`${ticketServiceUrl}/tickets/${id}`);
    res.json(ticketResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

// **Event Routes**

/**
 * Create a new event (Admin only)
 * @route POST /events
 * @param {Object} req.body - Event data
 * @param {string} req.body.name - Event name
 * @param {string} req.body.description - Event description
 * @param {string} req.body.date - Event date
 * @param {string} req.body.location - Location ID
 * @param {number} req.body.price - Event price
 * @param {string} req.body.type - Event type
 * @returns {Object} Created event data
 */
app.post("/events", verifyAdmin, largePayloadMiddleware, async (req, res) => {
  try {
    const eventResponse = await axios.post(`${eventServiceUrl}/event`, req.body);
    res.json(eventResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Update an event (Admin only)
 * @route PUT /events/:eventId
 * @param {string} req.params.eventId - Event ID
 * @param {Object} req.body - Updated event data
 * @returns {Object} Updated event data
 */
app.put("/events/:eventId", verifyAdmin, largePayloadMiddleware, async (req, res) => {
  try {
    const { eventId } = req.params;
    const eventResponse = await axios.put(`${eventServiceUrl}/events/${eventId}`, req.body);
    res.json(eventResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Update event image (Admin only)
 * @route PATCH /events/:eventId/image
 * @param {string} req.params.eventId - Event ID
 * @param {Object} req.body - Image data
 * @returns {Object} Updated event with new image
 */
app.patch("/events/:eventId/image", verifyAdmin, largePayloadMiddleware, async (req, res) => {
  try {
    const { eventId } = req.params;
    const eventResponse = await axios.patch(`${eventServiceUrl}/events/${eventId}/image`, req.body);
    res.json(eventResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Get all events
 * @route GET /events
 * @returns {Array} List of all events with location data
 */
app.get("/events", async (req, res) => {
  try {
    const eventsResponse = await axios.get(`${eventServiceUrl}/events`);
    res.json(eventsResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Get specific event by ID
 * @route GET /events/:eventId
 * @param {string} req.params.eventId - Event ID
 * @returns {Object} Event details with location data
 */
app.get("/events/:eventId", async (req, res) => {
  try {
    const eventResponse = await axios.get(`${eventServiceUrl}/events/${req.params.eventId}`);
    res.json(eventResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Manually update event states (Admin only)
 * @route POST /events/update-states
 * @param {Object} req.body - State update data
 * @returns {Object} State update confirmation
 */
app.post("/events/update-states", verifyAdmin, async (req, res) => {
  try {
    const eventResponse = await axios.post(`${eventServiceUrl}/events/update-states`, req.body);
    res.json(eventResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Get event statistics by state (Admin only)
 * @route GET /events/stats/states
 * @returns {Object} Event statistics grouped by state
 */
app.get("/events/stats/states", verifyAdmin, async (req, res) => {
  try {
    const eventResponse = await axios.get(`${eventServiceUrl}/events/stats/states`);
    res.json(eventResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Change event state (Admin only)
 * @route PATCH /events/:eventId/state
 * @param {string} req.params.eventId - Event ID
 * @param {Object} req.body - New state data
 * @returns {Object} Updated event with new state
 */
app.patch("/events/:eventId/state", verifyAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;
    const eventResponse = await axios.patch(`${eventServiceUrl}/events/${eventId}/state`, req.body);
    res.json(eventResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Update seat blocks for an event (Admin only)
 * @route PUT /events/:eventId/seat-blocks
 * @param {string} req.params.eventId - Event ID
 * @param {Object} req.body - Seat block data
 * @returns {Object} Updated seat blocks
 */
app.put("/events/:eventId/seat-blocks", verifyAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;
    const eventResponse = await axios.put(`${eventServiceUrl}/events/${eventId}/seat-blocks`, req.body);
    res.json(eventResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Delete an event (Admin only)
 * @route DELETE /events/:eventId
 * @param {string} req.params.eventId - Event ID
 * @returns {Object} Deletion confirmation
 */
app.delete("/events/:eventId", verifyAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;
    const eventResponse = await axios.delete(`${eventServiceUrl}/events/${eventId}`);
    res.json(eventResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Cancel an event (Admin only - creator admin)
 * @route DELETE /events/:eventId/cancel
 * @param {string} req.params.eventId - Event ID
 * @param {Object} req.body - Cancellation data
 * @returns {Object} Cancellation confirmation
 */
app.delete("/events/:eventId/cancel", verifyAdmin, async (req, res) => {
  try {
    const { eventId } = req.params;
    const eventResponse = await axios.delete(`${eventServiceUrl}/events/${eventId}/cancel`, {
      data: req.body
    });
    res.json(eventResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Get event statistics with sales data (Admin only)
 * @route GET /events/admin/statistics
 * @param {Object} [req.query] - Query parameters for filtering statistics
 * @returns {Object} Event statistics with sales information
 */
app.get("/events/admin/statistics", verifyAdmin, async (req, res) => {
  try {
    const eventResponse = await axios.get(`${eventServiceUrl}/events/admin/statistics`, {
      params: req.query
    });
    res.json(eventResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

// **Location Routes**

/**
 * Create a new location (Admin only)
 * @route POST /location
 * @param {Object} req.body - Location data
 * @param {string} req.body.name - Location name
 * @param {string} req.body.category - Location category
 * @param {string} req.body.address - Location address
 * @param {string} [req.body.seatMapId] - Associated seatmap ID
 * @param {number} [req.body.capacity] - Location capacity
 * @returns {Object} Created location data
 */
app.post("/location", verifyAdmin, async (req, res) => {
  try {
    const locationResponse = await axios.post(`${locationServiceUrl}/location`, req.body);
    res.json(locationResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Get all locations
 * @route GET /locations
 * @returns {Array} List of all locations
 */
app.get("/locations", async (req, res) => {
  try {
    const locationsResponse = await axios.get(`${locationServiceUrl}/locations`);
    res.json(locationsResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

/**
 * Get specific location by ID
 * @route GET /locations/:locationId
 * @param {string} req.params.locationId - Location ID
 * @returns {Object} Location details
 */
app.get("/locations/:locationId", async (req, res) => {
  try {
    const locationResponse = await axios.get(`${locationServiceUrl}/locations/${req.params.locationId}`);
    res.json(locationResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

app.get("/seatmaps", async (req, res) => {
  try {
    const seatMapsResponse = await axios.get(`${locationServiceUrl}/seatmaps`, {
      params: req.query
    });
    res.json(seatMapsResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

app.post("/seatmaps", verifyAdmin, async (req, res) => {
  try {
    const locationResponse = await axios.post(`${locationServiceUrl}/seatmaps`, req.body);
    res.json(locationResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

app.get("/seatmaps/:id", async (req, res) => {
  try {
    const seatMapResponse = await axios.get(`${locationServiceUrl}/seatmaps/${req.params.id}`);
    res.json(seatMapResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

app.get('/location/:locationId/sections', async (req, res) => {
  try {
    const seatMapResponse = await axios.get(`${locationServiceUrl}/location/${req.params.locationId}/sections`);
    res.json(seatMapResponse.data);
  } catch (error) {
    returnError(res, error);
  }
});

// Start the gateway service
const server = app.listen(port, () => {
  console.log(`Gateway Service listening at http://localhost:${port}`);
});

export default server;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-components_colorscheme.html">components/colorscheme</a></li><li><a href="module-models_Event.html">models/Event</a></li><li><a href="module-models_Location.html">models/Location</a></li><li><a href="module-models_SeatMap.html">models/SeatMap</a></li><li><a href="module-models_Ticket.html">models/Ticket</a></li><li><a href="module-models_User.html">models/User</a></li><li><a href="module-services_UserService.html">services/UserService</a></li><li><a href="module-utils_api.html">utils/api</a></li><li><a href="module-utils_authSession.html">utils/authSession</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AboutUs">AboutUs</a></li><li><a href="global.html#AdminDashboard">AdminDashboard</a></li><li><a href="global.html#AdminStatistics">AdminStatistics</a></li><li><a href="global.html#App">App</a></li><li><a href="global.html#BlockingViewSwitcher">BlockingViewSwitcher</a></li><li><a href="global.html#EditProfile">EditProfile</a></li><li><a href="global.html#EditableSeatRenderer">EditableSeatRenderer</a></li><li><a href="global.html#ErrorPage">ErrorPage</a></li><li><a href="global.html#EventCreation">EventCreation</a></li><li><a href="global.html#EventDetails">EventDetails</a></li><li><a href="global.html#FramedImage">FramedImage</a></li><li><a href="global.html#GeneralAdmissionRenderer">GeneralAdmissionRenderer</a></li><li><a href="global.html#GenericSeatRenderer">GenericSeatRenderer</a></li><li><a href="global.html#HelpCenter">HelpCenter</a></li><li><a href="global.html#Home">Home</a></li><li><a href="global.html#Login">Login</a></li><li><a href="global.html#ManualBlockingSelection">ManualBlockingSelection</a></li><li><a href="global.html#ManualSeatSelection">ManualSeatSelection</a></li><li><a href="global.html#Profile">Profile</a></li><li><a href="global.html#Register">Register</a></li><li><a href="global.html#RowPricingTable">RowPricingTable</a></li><li><a href="global.html#SeatMapContainer">SeatMapContainer</a></li><li><a href="global.html#SeatRenderer">SeatRenderer</a></li><li><a href="global.html#SeatSelectionViewSwitcher">SeatSelectionViewSwitcher</a></li><li><a href="global.html#SectionShapeRenderer">SectionShapeRenderer</a></li><li><a href="global.html#SelectionTopBar">SelectionTopBar</a></li><li><a href="global.html#TicketPurchase">TicketPurchase</a></li><li><a href="global.html#VenueStageRenderer">VenueStageRenderer</a></li><li><a href="global.html#ZoomControls">ZoomControls</a></li><li><a href="global.html#enviarEmailConfirmacionCompra">enviarEmailConfirmacionCompra</a></li><li><a href="global.html#generateTicketNumber">generateTicketNumber</a></li><li><a href="global.html#generateToken">generateToken</a></li><li><a href="global.html#generateValidationCode">generateValidationCode</a></li><li><a href="global.html#returnError">returnError</a></li><li><a href="global.html#tokens">tokens</a></li><li><a href="global.html#transporter">transporter</a></li><li><a href="global.html#useAdvancedZoomPan">useAdvancedZoomPan</a></li><li><a href="global.html#useDeviceDetection">useDeviceDetection</a></li><li><a href="global.html#useUserRole">useUserRole</a></li><li><a href="global.html#verifyAdmin">verifyAdmin</a></li><li><a href="global.html#verifyAuthenticated">verifyAuthenticated</a></li><li><a href="global.html#verifyOwnership">verifyOwnership</a></li><li><a href="global.html#verifyPayPalPayment">verifyPayPalPayment</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Wed Nov 12 2025 23:25:44 GMT+0100 (hora estándar de Europa central)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
