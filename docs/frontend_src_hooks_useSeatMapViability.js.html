<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: frontend/src/hooks/useSeatMapViability.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: frontend/src/hooks/useSeatMapViability.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file Hook personalizado para determinar viabilidad de renderizado de mapa de asientos
 * @module hooks/useSeatMapViability
 * @description Analiza complejidad del mapa de asientos, capacidades del dispositivo y determina estrategia óptima de renderizado
 */

import { useState, useEffect, useMemo } from 'react';
import useDeviceDetection from './useDeviceDetection';

/**
 * Hook para determinar si un mapa de asientos es viable de renderizar basado en dispositivo y complejidad
 * @param {Object} seatMapData - Datos de configuración del mapa de asientos
 * @param {Array} seatMapData.sections - Array de secciones del lugar
 * @param {string} seatMapData.type - Tipo de lugar (stadium, cinema, theater, concert)
 * @param {Object} [containerDimensions=null] - Dimensiones opcionales del contenedor
 * @param {number} containerDimensions.width - Ancho del contenedor en píxeles
 * @param {number} containerDimensions.height - Alto del contenedor en píxeles
 * @returns {Object} Resultados del análisis de viabilidad
 * @returns {boolean} isViable - Si el mapa de asientos puede renderizarse efectivamente
 * @returns {string|null} reason - Razón si no es viable
 * @returns {string} recommendedView - Modo de vista recomendado (full, list, simplified, blocks, zoomed)
 * @returns {number} scaleFactor - Factor de escala calculado para el renderizado
 * @returns {boolean} hasOverlaps - Si las secciones se superponen
 * @returns {number} overlapCount - Número de superposiciones detectadas
 * @returns {number} minRequiredWidth - Ancho mínimo necesario para renderizado óptimo
 * @returns {number} minRequiredHeight - Alto mínimo necesario para renderizado óptimo
 */
const useSeatMapViability = (seatMapData, containerDimensions = null) => {
  const deviceInfo = useDeviceDetection();
  const [viability, setViability] = useState({
    isViable: true,
    reason: null,
    recommendedView: 'full',
    scaleFactor: 1,
    hasOverlaps: false,
    overlapCount: 0,
    minRequiredWidth: 0,
    minRequiredHeight: 0
  });

  // Calcular dimensiones requeridas para el mapa
  const calculateRequiredDimensions = useMemo(() => {
    if (!seatMapData?.sections) return { width: 0, height: 0 };

    const { sections, type } = seatMapData;
    let totalWidth = 0;
    let totalHeight = 0;

    switch (type) {
      case 'stadium': {
        // Layout de estadio: tribunas alrededor del campo
        const fieldWidth = 400;
        const fieldHeight = 260;
        const tribunaWidth = Math.max(...sections.map(s => s.seatsPerRow * 24 + 100));
        const tribunaHeight = Math.max(...sections.map(s => s.rows * 24 + 100));

        totalWidth = fieldWidth + (tribunaWidth * 2) + 160; // Campo + 2 tribunas + espaciado
        totalHeight = fieldHeight + (tribunaHeight * 2) + 120; // Campo + 2 tribunas + espaciado
        break;
      }

      case 'cinema': {
        // Layout de cine: secciones apiladas verticalmente
        const screenWidth = 400;
        const sectionWidth = Math.max(...sections.map(s => s.seatsPerRow * 24 + 100));
        const totalSectionsHeight = sections.reduce((acc, s) => acc + (s.rows * 24 + 100), 0);

        totalWidth = Math.max(screenWidth, sectionWidth) + 100;
        totalHeight = totalSectionsHeight + 200; // Secciones + pantalla + espaciado
        break;
      }

      case 'theater': {
        // Layout de teatro: similar al cine pero con más espaciado
        const stageWidth = 350;
        const theaterSectionWidth = Math.max(...sections.map(s => s.seatsPerRow * 24 + 100));
        const totalTheaterHeight = sections.reduce((acc, s) => acc + (s.rows * 24 + 120), 0);

        totalWidth = Math.max(stageWidth, theaterSectionWidth) + 120;
        totalHeight = totalTheaterHeight + 250;
        break;
      }

      case 'concert': {
        // Layout de concierto: escenario central con secciones alrededor
        const stageWidth = 300;
        const stageHeight = 80;
        const concertSectionWidth = Math.max(...sections.map(s => s.seatsPerRow * 24 + 100));
        const concertSectionHeight = Math.max(...sections.map(s => s.rows * 24 + 100));

        totalWidth = stageWidth + (concertSectionWidth * 2) + 200;
        totalHeight = stageHeight + (concertSectionHeight * 2) + 150;
        break;
      }

      default: {
        // Layout genérico: grid de secciones
        const maxSeatsPerRow = Math.max(...sections.map(s => s.seatsPerRow));
        const maxRows = Math.max(...sections.map(s => s.rows));
        const sectionWidth = maxSeatsPerRow * 24 + 100;
        const sectionHeight = maxRows * 24 + 100;

        // Calcular grid
        const cols = Math.ceil(Math.sqrt(sections.length));
        const rows = Math.ceil(sections.length / cols);

        totalWidth = (sectionWidth * cols) + (20 * (cols - 1)) + 100;
        totalHeight = (sectionHeight * rows) + (20 * (rows - 1)) + 100;
        break;
      }
    }

    return { width: totalWidth, height: totalHeight };
  }, [seatMapData]);

  // Detectar colisiones entre secciones
  const detectOverlaps = useMemo(() => {
    if (!seatMapData?.sections) return { hasOverlaps: false, overlapCount: 0 };

    const { sections, type } = seatMapData;
    let overlaps = 0;

    // Para layouts específicos, verificar superposiciones lógicas
    if (type === 'stadium') {
      const tribunas = sections.filter(s =>
        s.position === 'north' || s.position === 'south' ||
        s.position === 'east' || s.position === 'west'
      );

      // Verificar si hay demasiadas tribunas para el espacio disponible
      if (tribunas.length > 4) {
        overlaps += tribunas.length - 4;
      }
    }

    // Verificar secciones con dimensiones excesivas
    sections.forEach(section => {
      const sectionArea = section.rows * section.seatsPerRow;
      const maxReasonableArea = 500; // Área máxima razonable para una sección

      if (sectionArea > maxReasonableArea) {
        overlaps += 1;
      }
    });

    return {
      hasOverlaps: overlaps > 0,
      overlapCount: overlaps
    };
  }, [seatMapData]);

  // Calcular factor de escala necesario
  const calculateScaleFactor = useMemo(() => {
    const { width: requiredWidth, height: requiredHeight } = calculateRequiredDimensions;
    const availableWidth = containerDimensions?.width || deviceInfo.screenWidth;
    const availableHeight = containerDimensions?.height || deviceInfo.screenHeight - 200; // Restar espacio para UI

    const scaleX = availableWidth / requiredWidth;
    const scaleY = availableHeight / requiredHeight;
    const scale = Math.min(scaleX, scaleY, 1); // No escalar más allá del 100%

    return Math.max(scale, 0.1); // Mínimo 10% para mantener visibilidad
  }, [calculateRequiredDimensions, containerDimensions, deviceInfo]);

  // Determinar la viabilidad y vista recomendada
  const determineViability = useMemo(() => {
    const { width: requiredWidth, height: requiredHeight } = calculateRequiredDimensions;
    const availableWidth = containerDimensions?.width || deviceInfo.screenWidth;
    const availableHeight = containerDimensions?.height || deviceInfo.screenHeight - 200;

    const { hasOverlaps, overlapCount } = detectOverlaps;
    const scaleFactor = calculateScaleFactor;

    // Criterios de viabilidad
    const isTooSmall = scaleFactor &lt; 0.3; // Menos del 30% de escala
    const hasTooManyOverlaps = overlapCount > 2;
    const isMobileAndComplex = deviceInfo.isMobile &amp;&amp; (requiredWidth > 600 || requiredHeight > 400);
    const isTabletAndVeryComplex = deviceInfo.isTablet &amp;&amp; (requiredWidth > 1000 || requiredHeight > 600);

    let isViable = true;
    let reason = null;
    let recommendedView = 'full';

    if (isTooSmall) {
      isViable = false;
      reason = 'El mapa es demasiado pequeño para ser legible';
      recommendedView = 'list';
    } else if (hasTooManyOverlaps) {
      isViable = false;
      reason = 'Demasiadas superposiciones entre secciones';
      recommendedView = 'simplified';
    } else if (isMobileAndComplex) {
      isViable = false;
      reason = 'Mapa demasiado complejo para pantalla móvil';
      recommendedView = 'list';
    } else if (isTabletAndVeryComplex) {
      isViable = false;
      reason = 'Mapa muy complejo para tablet';
      recommendedView = 'blocks';
    } else if (scaleFactor &lt; 0.6) {
      // Mapa viable pero con zoom recomendado
      recommendedView = 'zoomed';
    }

    return {
      isViable,
      reason,
      recommendedView,
      scaleFactor,
      hasOverlaps,
      overlapCount,
      minRequiredWidth: requiredWidth,
      minRequiredHeight: requiredHeight
    };
  }, [calculateRequiredDimensions, detectOverlaps, calculateScaleFactor, deviceInfo, containerDimensions]);

  // Actualizar viabilidad cuando cambien las dependencias
  useEffect(() => {
    setViability(determineViability);
  }, [determineViability]);

  return viability;
};

export default useSeatMapViability;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-components_colorscheme.html">components/colorscheme</a></li><li><a href="module-hooks_useSeatMapViability.html">hooks/useSeatMapViability</a></li><li><a href="module-models_Event.html">models/Event</a></li><li><a href="module-models_Location.html">models/Location</a></li><li><a href="module-models_SeatMap.html">models/SeatMap</a></li><li><a href="module-models_Ticket.html">models/Ticket</a></li><li><a href="module-models_User.html">models/User</a></li><li><a href="module-services_UserService.html">services/UserService</a></li><li><a href="module-utils_authSession.html">utils/authSession</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AboutUs">AboutUs</a></li><li><a href="global.html#AdminDashboard">AdminDashboard</a></li><li><a href="global.html#AdminStatistics">AdminStatistics</a></li><li><a href="global.html#App">App</a></li><li><a href="global.html#BlockingViewSwitcher">BlockingViewSwitcher</a></li><li><a href="global.html#EditProfile">EditProfile</a></li><li><a href="global.html#EditableSeatRenderer">EditableSeatRenderer</a></li><li><a href="global.html#ErrorPage">ErrorPage</a></li><li><a href="global.html#EventCreation">EventCreation</a></li><li><a href="global.html#EventDetails">EventDetails</a></li><li><a href="global.html#FramedImage">FramedImage</a></li><li><a href="global.html#GeneralAdmissionRenderer">GeneralAdmissionRenderer</a></li><li><a href="global.html#GenericSeatRenderer">GenericSeatRenderer</a></li><li><a href="global.html#HelpCenter">HelpCenter</a></li><li><a href="global.html#Home">Home</a></li><li><a href="global.html#Login">Login</a></li><li><a href="global.html#ManualBlockingSelection">ManualBlockingSelection</a></li><li><a href="global.html#ManualSeatSelection">ManualSeatSelection</a></li><li><a href="global.html#Navbar">Navbar</a></li><li><a href="global.html#Profile">Profile</a></li><li><a href="global.html#Register">Register</a></li><li><a href="global.html#RowPricingTable">RowPricingTable</a></li><li><a href="global.html#SeatMapContainer">SeatMapContainer</a></li><li><a href="global.html#SeatRenderer">SeatRenderer</a></li><li><a href="global.html#SeatSelectionViewSwitcher">SeatSelectionViewSwitcher</a></li><li><a href="global.html#SectionShapeRenderer">SectionShapeRenderer</a></li><li><a href="global.html#SelectionTopBar">SelectionTopBar</a></li><li><a href="global.html#TicketPurchase">TicketPurchase</a></li><li><a href="global.html#VenueStageRenderer">VenueStageRenderer</a></li><li><a href="global.html#ZoomControls">ZoomControls</a></li><li><a href="global.html#enviarEmailConfirmacionCompra">enviarEmailConfirmacionCompra</a></li><li><a href="global.html#generateTicketNumber">generateTicketNumber</a></li><li><a href="global.html#generateValidationCode">generateValidationCode</a></li><li><a href="global.html#returnError">returnError</a></li><li><a href="global.html#transporter">transporter</a></li><li><a href="global.html#useAdvancedZoomPan">useAdvancedZoomPan</a></li><li><a href="global.html#useDeviceDetection">useDeviceDetection</a></li><li><a href="global.html#useUserRole">useUserRole</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Thu Oct 23 2025 19:08:08 GMT+0200 (hora de verano de Europa central)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
